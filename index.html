<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <link type="text/css" rel="stylesheet" href="/assets/css/styles.css"/>
        <style>
            .chart {
                display: block;
                margin: auto;
                margin-top: 40px;
            }

            text {
                font-size: 11px;
            }

            rect {
                fill: none;
            }
        </style>
    </head>
    <body>
        <div id="body"></div>
        <div id="footer">
            <form>
                <select>
                    <option value="size">Size</option>
                    <option value="count">Count</option>
                </select>
            </form>
        </div>
        <script src="/bower_components/momentjs/min/moment.min.js"></script>
        <script src="/bower_components/d3/d3.min.js"></script>
        <script>

            /*
             * initialize datas
             */
            var ramp = d3.scale.linear().domain([0,100]).range(["green","red"]);
            var olderUnchangedDays = 0;

            var formattedDatas = {
                name: '/',
                children: []
            };

            var margin = {top: 40, right: 10, bottom: 10, left: 10},
                    width = 1280 - margin.left - margin.right,
                    height = 800 - margin.top - margin.bottom,
                    x = d3.scale.linear().range([0, width]),
                    y = d3.scale.linear().range([0, height]),
                    root,
                    node,
                    color = d3.scale.category20c();

            var treemap = d3.layout.treemap()
                    .round(false)
                    .size([width, height])
                    .sticky(true)
                    .value(function(d) { return d.size; });

            var svg = d3.select("#body")
                .append("div")
                    .attr("class", "chart")
                    .style("width", width + "px")
                    .style("height", height + "px")
                .append("svg:svg")
                    .attr("width", width)
                    .attr("height", height)
                .append("svg:g")
                    .attr("transform", "translate(.5,.5)");


            /*
             * Build treemap
             */
            d3.csv('/datas.csv', function(error, datas) {

                datas.forEach(function(file) {
                    createPath(formattedDatas, 0, file);

                    var nbOfUnchangedDays = moment().diff(moment(file.date), 'days');

                    if (nbOfUnchangedDays > olderUnchangedDays) {
                        olderUnchangedDays = nbOfUnchangedDays;
                    }
                });

                node = root = formattedDatas;

                var nodes = treemap.nodes(root).filter(function(d) { return !d.children; });

                var cell = svg.selectAll("g")
                    .data(nodes)
                    .enter().append("svg:g")
                    .attr("class", "cell")
                    .attr("transform", function(d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    })
                    .on("click", function(d) {
                        return zoom(node == d.parent ? root : d.parent);
                    });

                cell.append("svg:rect")
                    .attr("width", function(d) {
                        var width = d.dx - 1;
                        return width > 0 ? width : 0;
                    })
                    .attr("height", function(d) {
                        var height = d.dy - 1;
                        return height > 0 ? height : 0;
                    })
                    .style("fill", function(d) {
                        return ramp((d.days * 100) / olderUnchangedDays);
                    });

                cell.append("svg:text")
                    .attr("x", function(d) {
                        return d.dx / 2;
                    })
                    .attr("y", function(d) {
                        return d.dy / 2;
                    })
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle")
                    .text(function(d) {
                        return d.name;
                    })
                    .style("opacity", function(d) {
                        d.w = this.getComputedTextLength();
                        return d.dx > d.w ? 1 : 0;
                    });

                d3.select(window).on("click", function() { zoom(root); });

                d3.select("select").on("change", function() {
                    treemap.value(this.value == "size" ? size : count).nodes(root);
                    zoom(node);
                });
            })


            /*
             * tool functions
             */
            function size(d) {
                return d.size;
            }

            function count(d) {
                return 1;
            }

            function zoom(d) {
                var kx = width / d.dx, ky = height / d.dy;
                x.domain([d.x, d.x + d.dx]);
                y.domain([d.y, d.y + d.dy]);

                var t = svg.selectAll("g.cell").transition()
                    .duration(d3.event.altKey ? 7500 : 750)
                    .attr("transform", function(d) { return "translate(" + x(d.x) + "," + y(d.y) + ")"; });

                t.select("rect")
                    .attr("width", function(d) {
                        var width = kx * d.dx - 1;
                        return width > 0 ? width : 0;
                    })
                    .attr("height", function(d) {
                        var height = ky * d.dy - 1;
                        return height > 0 ? height : 0;
                    })

                t.select("text")
                    .attr("x", function(d) {
                        return kx * d.dx / 2;
                    })
                    .attr("y", function(d) {
                        return ky * d.dy / 2;
                    })
                    .style("opacity", function(d) {
                        return kx * d.dx > d.w ? 1 : 0;
                    });

                node = d;
                d3.event.stopPropagation();
            }

            function createPath(cursor, level, file) {
                var filePaths = file.filePath.split('/'),
                        path = filePaths[level];

                // If we are at the last level of the filepath, the file cannot already be in the formattedDatas
                // so we push it and we return to handle the next file
                if(level === filePaths.length - 1) {
                    cursor.children.push({
                        name: file.filePath,
                        days: moment().diff(moment(file.date), 'days'),
                        size: file.nbCommits * 1000
                    });
                    return;
                }

                // We loop on the children to know if the element is already in the formattedDatas
                // if so, we call this method on its children, with one more level in the filepath
                for(var i in cursor.children) {
                    if (!cursor.children.hasOwnProperty(i)) {
                        continue;
                    }
                    var child = cursor.children[i];

                    if(child.name === path) {
                        return createPath(child, level + 1, file);
                    }
                };

                // The element is not already in the formattedDatas
                // we add it, and then call this method on its empty children, with one more level in the filepath
                var child = {
                    name: path,
                    children: []
                };

                cursor.children.push(child)
                createPath(child, level + 1, file);
            }
        </script>
    </body>
</html>




