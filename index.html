<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <link type="text/css" rel="stylesheet" href="/assets/css/styles.css"/>
        <style>
            .chart {
                display: block;
                margin: auto;
                margin-top: 40px;
            }

            text {
                font-size: 11px;
            }

            rect {
                fill: none;
                cursor: default;
            }

            .label {
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .background {
                stroke: #ffffff;
            }
        </style>
    </head>
    <body>
        <div id="body"></div>
        <did id="detail">
            <p>
                <span class="name"></span><br>
                (<span class="commits"></span> commit(s), derni√®re modification il y a <span class="days"></span> jour(s)).
            </p>
        </did>
        <script src="/bower_components/momentjs/min/moment.min.js"></script>
        <script src="/bower_components/d3/d3.min.js"></script>
        <script>

            /*
             * initialize datas
             */
            var ramp = d3.scale.linear().domain([0,100]).range(["green","red"]);
            var olderUnchangedDays = 0;
            var transitionDuration = 500;

            var formattedDatas = {
                name: '/',
                children: []
            };

            var margin = {top: 40, right: 10, bottom: 10, left: 10},
                    width = 1280 - margin.left - margin.right,
                    height = 800 - margin.top - margin.bottom,
                    x = d3.scale.linear().range([0, width]),
                    y = d3.scale.linear().range([0, height]),
                    root,
                    node;
            var treemap = d3.layout.treemap()
                    .round(false)
                    .size([width, height])
                    .sticky(true)
                    .value(function(d) { return d.size; });

            var svg = d3.select("#body")
                .append("div")
                    .attr("class", "chart")
                    .style("width", width + "px")
                    .style("height", height + "px")
                .append("svg:svg")
                    .attr("width", width)
                    .attr("height", height)
                .append("svg:g")
                    .attr("transform", "translate(.5,.5)");

            var defs = svg.append("defs");

            var filter = defs.append("svg:filter")
                    .attr("id", "outerDropShadow")
                    .attr("x", "-20%")
                    .attr("y", "-20%")
                    .attr("width", "140%")
                    .attr("height", "140%");

            filter.append("svg:feOffset")
                    .attr("result", "offOut")
                    .attr("in", "SourceGraphic")
                    .attr("dx", "1")
                    .attr("dy", "1");

            filter.append("svg:feColorMatrix")
                    .attr("result", "matrixOut")
                    .attr("in", "offOut")
                    .attr("type", "matrix")
                    .attr("values", "1 0 0 0 0 0 0.1 0 0 0 0 0 0.1 0 0 0 0 0 .5 0");

            filter.append("svg:feGaussianBlur")
                    .attr("result", "blurOut")
                    .attr("in", "matrixOut")
                    .attr("stdDeviation", "3");

            filter.append("svg:feBlend")
                    .attr("in", "SourceGraphic")
                    .attr("in2", "blurOut")
                    .attr("mode", "normal");


            /*
             * Build treemap
             */
            d3.csv('/datas.csv', function(error, datas) {

                datas.forEach(function(file) {
                    createPath(formattedDatas, 0, file);

                    var nbOfUnchangedDays = moment().diff(moment(file.date), 'days');

                    if (nbOfUnchangedDays > olderUnchangedDays) {
                        olderUnchangedDays = nbOfUnchangedDays;
                    }
                });

                node = root = formattedDatas;

                var nodes = treemap.nodes(root).filter(function(d) { return !d.children; });

                var cell = svg.selectAll("g")
                    .data(nodes)
                    .enter().append("svg:g")
                    .attr("class", "cell")
                    .attr("transform", function(d) {
                        return "translate(" + d.x + "," + d.y + ")";
                    })
                    .on("click", function(d) {
                        return zoom(node == d.parent ? root : d.parent);
                    })
                    .on("mouseover", function(d) {
                        this.parentNode.appendChild(this); // workaround for bringing elements to the front (ie z-index)
                        d3.select(this)
                            .attr("filter", "url(#outerDropShadow)")
                            .select(".background")
                            .style("stroke", "#000000");

                        var detail = d3.select("#detail");
                        detail.select('.name').text(d.filepath);
                        detail.select('.commits').text(d.size);
                        detail.select('.days').text(d.days);
                        detail.style('display', 'block');
                    })
                    .on("mouseout", function() {
                        d3.select(this)
                            .attr("filter", "")
                            .select(".background")
                            .style("stroke", "#FFFFFF");
                        var detail = d3.select("#detail");
                        detail.style('display', 'none');
                    });

                cell.append("svg:rect")
                    .attr("width", function(d) {
                        return Math.max(0.01, d.dx);
                    })
                    .attr("height", function(d) {
                        return Math.max(0.01, d.dy);
                    })
                    .style("fill", function(d) {
                        return ramp((d.days * 100) / olderUnchangedDays);
                    })
                    .classed("background", true);

                cell.append("svg:text")
                    .attr("x", function(d) {
                        return d.dx / 2;
                    })
                    .attr("y", function(d) {
                        return d.dy / 2;
                    })
                    .attr("dy", ".35em")
                    .attr("text-anchor", "middle")
                    .text(function(d) {
                        return d.name;
                    })
                    .style("display", function(d) {
                        d.w = this.getComputedTextLength();
                        return d.dx > d.w ? 'block' : 'none';
                    });

                d3.select(window).on("click", function() { zoom(root); });
            })


            /*
             * tool functions
             */
            function size(d) {
                return d.size;
            }

            function zoom(d) {
                this.treemap
                        .nodes(d);

                // moving the next two lines above treemap layout messes up padding of zoom result
                var kx = width  / d.dx;
                var ky = height / d.dy;
                var level = d;

                x.domain([d.x, d.x + d.dx]);
                y.domain([d.y, d.y + d.dy]);

                var zoomTransition = svg.selectAll("g.cell").transition().duration(transitionDuration)
                    .attr("transform", function(d) {
                        return "translate(" + x(d.x) + "," + y(d.y) + ")";
                    })


                // update the width/height of the rects
                zoomTransition.select("rect")
                    .attr("width", function(d) {
                        return Math.max(0.01, kx * d.dx);
                    })
                    .attr("height", function(d) {
                        return Math.max(0.01, ky * d.dy);
                    })
                    .style("fill", function(d) {
                        return ramp((d.days * 100) / olderUnchangedDays);
                    })
                ;

                zoomTransition.select("rect text").style("display", function(d) {
                    d.w = this.getComputedTextLength();
                    return d.dx > d.w ? 'block' : 'block';
                });

                node = d;

                if (d3.event) {
                    d3.event.stopPropagation();
                }
            }

            function createPath(cursor, level, file) {
                var filePaths = file.filePath.split('/'),
                        path = filePaths[level];

                // If we are at the last level of the filepath, the file cannot already be in the formattedDatas
                // so we push it and we return to handle the next file
                if(level === filePaths.length - 1) {
                    cursor.children.push({
                        name: path,
                        filepath: file.filePath,
                        days: moment().diff(moment(file.date), 'days'),
                        size: file.nbCommits
                    });
                    return;
                }

                // We loop on the children to know if the element is already in the formattedDatas
                // if so, we call this method on its children, with one more level in the filepath
                for(var i in cursor.children) {
                    if (!cursor.children.hasOwnProperty(i)) {
                        continue;
                    }
                    var child = cursor.children[i];

                    if(child.name === path) {
                        return createPath(child, level + 1, file);
                    }
                };

                // The element is not already in the formattedDatas
                // we add it, and then call this method on its empty children, with one more level in the filepath
                var child = {
                    name: path,
                    children: []
                };

                cursor.children.push(child)
                createPath(child, level + 1, file);
            }
        </script>
    </body>
</html>

